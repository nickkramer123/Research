# Rossler Attractor

import numpy as np
from scipy.integrate import odeint
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D

# parameters
a = .2
b_list = np.linspace(.1, 2, 250) # 250 values between 0 and 2
g = 5.7

# initial variable values
# good default, may need to change later
initVars = [1, 1, 1]

# generate a solution at 3000 evenly spaced samples in the interval 0 <= t <= 250.
tset = np.linspace(0, 250, 1500)

# FIRST ORDER OF BUISNESS
def rossler(initVars, t, alpha, beta, gamma):
    x = initVars[0]
    y = initVars[1]
    z = initVars[2]
    dxdt = - y - z # CHANGE MADE
    dydt = x + alpha * y
    dzdt = beta + z * (x - gamma) # THERE MAY BE TYPO HERE, CHANGED NOW
    return [dxdt, dydt, dzdt]


# func: the function that computes the derivatives
# y0: array, initial condition of x, y, z
# t: array, sequence of time points to solve for x, y, z
# args: extra arguments to pass through to function (alpha, beta, gamma)

# solutions in a dictionary, a list for each b value
sol_dict = {}

# create empty lists for bifurcation diagram
b_vals = []
z_steady_state =[] # long term (post-transient) values of z
x_steady_state =[] # long term (post-transient) values of x


for i, b in enumerate(b_list):
    sol = odeint(
        func = rossler, 
        y0 = initVars,
        t = tset,
        args = (a, b, g))
    sol_dict[b] = sol



    # extract values
    x_values = sol_dict[b][:, 0]
    y_values = sol_dict[b][:, 1]
    z_values = sol_dict[b][:, 2]



    # 3D Plots
    # For 5 different indexes
    if i % 50 == 0: 
        fig = plt.figure() # create figure
        ax = fig.add_subplot(111, projection='3d') # add new axis
        ax.scatter(xs = x_values, ys = y_values, zs = z_values, zdir='z', s=20, c=None, depthshade=True)
        ax.set_xlabel("X Axis")
        ax.set_ylabel("Y Axis")
        ax.set_zlabel("Z Axis")
        ax.set_title('Attractor at β = ' + f'{b:.3f}' + ':')

        plt.show()

    # collect z values
    for z in z_values[int(.5*len(z_values)):]: # getting rid off pre-transient behavior
        z_steady_state.append(z)
        b_vals.append(b)

    # collect x values
    for x in x_values[int(.5*len(x_values)):]: # getting rid off pre-transient behavior
        x_steady_state.append(x)



# # make bifurcation diagram for z
plt.scatter(x = b_vals, y = z_steady_state, s = .1, alpha=.2, color="black")
plt.xlabel("β (beta)")
plt.ylabel("z (Steady-State Values)")
plt.title("Bifurcation Diagram of the Rössler System for z")
plt.grid(True)
plt.show()

# # make bifurcation diagram for x
plt.scatter(x = b_vals, y = x_steady_state, s = .1, alpha=.2, color="brown")
plt.xlabel("β (beta)")
plt.ylabel("x (Steady-State Values)")
plt.title("Bifurcation Diagram of the Rössler System for x")
plt.grid(True)
plt.show()